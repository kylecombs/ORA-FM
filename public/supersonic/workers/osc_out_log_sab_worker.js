(()=>{function m({uint8View:t,dataView:o,bufferStart:e,bufferSize:r,head:l,tail:d,messageMagic:g,paddingMagic:i,headerSize:u,maxMessages:N=1/0,onMessage:p,onCorruption:a}){let s=d,O=0,C=G=>{let E=G;if(E+4<=r)return o.getUint32(e+E,!0);let A=0;for(let U=0;U<4;U++)A|=t[e+(E+U)%r]<<U*8;return A};for(;s!==l&&O<N;){let G=r-s,E;if(G>=4?E=o.getUint32(e+s,!0):E=C(s),E===i){s=0;continue}if(E!==g){a&&a(s),s=(s+1)%r;continue}let A=C((s+4)%r),U=C((s+8)%r),x=C((s+12)%r);if(A<u||A>r){a&&a(s),s=(s+1)%r;continue}let R=A-u,H=e+(s+u)%r;p(H,R,U,x),s=(s+A)%r,O++}return{newTail:s,messagesRead:O}}function B(t,o){let e=t+o;return{IN_HEAD:(e+0)/4,IN_TAIL:(e+4)/4,IN_SEQUENCE:(e+24)/4,IN_WRITE_LOCK:(e+40)/4,IN_LOG_TAIL:(e+44)/4}}var F=2208988800,M=()=>(performance.timeOrigin+performance.now())/1e3+F,f=null,L=null,c=null,S=null,I=null,n=null,_={},D=!1,y=(...t)=>{},w=(t,o,e)=>{f=t,L=o,n=e,c=new Int32Array(f),S=new DataView(f),I=new Uint8Array(f),_=B(L,n.CONTROL_START);let r=Atomics.load(c,_.IN_HEAD);Atomics.store(c,_.IN_LOG_TAIL,r),y("Initialized, IN_LOG_TAIL set to",r)},$=t=>{let o=L+n.IN_BUFFER_START,e=n.IN_BUFFER_SIZE;if(t+4<=e)return S.getUint32(o+t,!0);let r=0;for(let l=0;l<4;l++)r|=I[o+(t+l)%e]<<l*8;return r},T=()=>{let t=Atomics.load(c,_.IN_HEAD),o=Atomics.load(c,_.IN_LOG_TAIL);if(t===o)return[];if($(o)!==n.MESSAGE_MAGIC)return Atomics.store(c,_.IN_LOG_TAIL,t),[];let r=[],{newTail:l,messagesRead:d}=m({uint8View:I,dataView:S,bufferStart:L+n.IN_BUFFER_START,bufferSize:n.IN_BUFFER_SIZE,head:t,tail:o,messageMagic:n.MESSAGE_MAGIC,paddingMagic:n.PADDING_MAGIC,headerSize:n.MESSAGE_HEADER_SIZE,maxMessages:100,onMessage:(g,i,u,N)=>{let p=new Uint8Array(i);for(let a=0;a<i;a++)p[a]=I[g+a];r.push({sourceId:N,oscData:p,sequence:u,timestamp:M()})},onCorruption:g=>{if(T._corruptCount||(T._corruptCount=0),T._corruptCount++,T._corruptCount<=3){let i=L+n.IN_BUFFER_START+g,u=S.getUint32(i,!0),N=I[i],p=I[i+1],a=I[i+2],s=I[i+3],O=Atomics.load(c,_.IN_TAIL);console.error(`[OSCOutLogWorker] Corrupted message at position ${g}: head=${t} logTail=${o} inTail=${O} got=0x${(u>>>0).toString(16).padStart(8,"0")} expected=0x${(n.MESSAGE_MAGIC>>>0).toString(16).padStart(8,"0")} bytes=[${N},${p},${a},${s}] bufStart=${L+n.IN_BUFFER_START} bufSize=${n.IN_BUFFER_SIZE}`)}else T._corruptCount===4&&console.error(`[OSCOutLogWorker] Suppressing further corruption logs (${T._corruptCount}+ total)`)}});return d>0&&Atomics.store(c,_.IN_LOG_TAIL,l),r},b=()=>{for(;D;)try{let t=Atomics.load(c,_.IN_HEAD),o=Atomics.load(c,_.IN_LOG_TAIL);t===o&&Atomics.wait(c,_.IN_HEAD,t);let e=T();e.length>0&&self.postMessage({type:"oscLog",entries:e})}catch(t){console.error("[OSCOutLogWorker] Error in wait loop:",t),self.postMessage({type:"error",error:t.message}),Atomics.wait(c,0,c[0],10)}},k=()=>{if(!f){console.error("[OSCOutLogWorker] Cannot start - not initialized");return}D||(D=!0,b())},W=()=>{D=!1};self.addEventListener("message",t=>{let{data:o}=t;try{switch(o.type){case"init":w(o.sharedBuffer,o.ringBufferBase,o.bufferConstants),self.postMessage({type:"initialized"});break;case"start":k();break;case"stop":W();break;default:}}catch(e){console.error("[OSCOutLogWorker] Error:",e),self.postMessage({type:"error",error:e.message})}});y("Script loaded");})();
